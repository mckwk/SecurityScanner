import re
import requests
import spacy
import logging

import config
from log_and_file_managers.logger_manager import LoggerManager

logger_manager = LoggerManager(config.LOG_FILE)
logger = logger_manager.get_logger()


class VulnerabilityChecker:
    SUFFIXES = ['Inc.', 'Ltd.', 'Co.', 'Corporation', 'LLC',
                'SA', 'S.A', 'GmbH', 'AG', 'S.A.', 'Pvt.', 'PLC', 'Limited']
    KNOWN_BRANDS = ['xiaomi', 'apple', 'microsoft', 'samsung',
                    'huawei', 'lenovo', 'dell', 'hp', 'asus', 'acer']
    BASE_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    HEADERS = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36'
    }

    def __init__(self):
        self.nlp = spacy.load("en_core_web_sm")
        self.synonyms = self._load_synonyms()
        self.cache = {}

    def _load_synonyms(self):
        # Load or define synonyms for known terms
        return {
            'microsoft': ['ms', 'windows'],
            'apple': ['mac', 'ios'],
            'dell': ['alienware'],
            # Add more synonyms as needed
        }

    def extract_keyword(self, vendor_name):
        cleaned_name = self._clean_vendor_name(vendor_name)
        keywords = self._extract_keywords(cleaned_name)
        best_keyword = self._get_best_keyword(keywords, cleaned_name)
        logger.info("Extracted keyword for vendor '%s': %s", vendor_name, best_keyword)
        return best_keyword

    def _clean_vendor_name(self, vendor_name):
        pattern = re.compile(
            r'\b(?:' + '|'.join(self.SUFFIXES) + r')\b', re.IGNORECASE)
        vendor_name = pattern.sub('', vendor_name).strip()
        cleaned_name = re.sub(r'[^\w\s]', '', vendor_name)
        return cleaned_name

    def _extract_keywords(self, cleaned_name):
        doc = self.nlp(cleaned_name)
        keywords = [chunk.text.lower() for chunk in doc.noun_chunks if chunk.root.pos_ in ['PROPN', 'NOUN']]
        return keywords

    def _get_best_keyword(self, keywords, cleaned_name):
        for keyword in keywords:
            for brand in self.KNOWN_BRANDS:
                if brand in keyword:
                    return brand
        best_keyword = keywords[0] if keywords else cleaned_name.split()[0].lower()
        logger.info("Best keyword selected: %s", best_keyword)
        return best_keyword

    def search_vulnerabilities(self, OS, vendor, device_name="unknown", max_results=10):
        keywords = set()
        logger.info("Searching vulnerabilities for OS: %s, vendor: %s, device_name: %s", OS, vendor, device_name)

        if device_name.lower() != "unknown":
            keywords.add(self.extract_keyword(device_name))
        if OS.lower() != "unknown":
            keywords.add(OS)
        if vendor.lower() != "unknown":
            keywords.add(vendor)

        # Expand keywords with synonyms
        expanded_keywords = self._expand_keywords(keywords)

        # Combine keywords for a more specific search
        combined_keyword = " ".join(expanded_keywords)
        vulnerabilities = self._search_by_keyword(combined_keyword, max_results)

        # If no results, try individual keywords
        if not vulnerabilities:
            for keyword in expanded_keywords:
                vulnerabilities.extend(self._search_by_keyword(keyword, max_results))

        # Remove duplicates and prioritize results
        unique_vulnerabilities = {v['cve']['id']: v for v in vulnerabilities}.values()
        sorted_vulnerabilities = sorted(unique_vulnerabilities, key=lambda v: (v['cve']['metrics']['cvssMetricV2'][0]['baseSeverity'], v['cve']['published']), reverse=True)

        return list(sorted_vulnerabilities)

    def _expand_keywords(self, keywords):
        expanded_keywords = set(keywords)
        for keyword in keywords:
            if keyword in self.synonyms:
                expanded_keywords.update(self.synonyms[keyword])
        return expanded_keywords

    def _search_by_keyword(self, keyword, max_results):
        if keyword in self.cache:
            logger.info("Using cached results for keyword: %s", keyword)
            return self.cache[keyword]
        if keyword != '': 
            params = self._build_params(keyword, max_results)
            logger.info("Searching vulnerabilities with keyword: %s", keyword)
            response = requests.get(self.BASE_URL, params=params, headers=self.HEADERS)
            vulnerabilities = self._parse_response(response)

        # Cache the results
        self.cache[keyword] = vulnerabilities
        return vulnerabilities

    def _build_params(self, keyword, max_results):
        params = {
            'keywordSearch': keyword,
            'resultsPerPage': max_results
        }
        if ' ' not in keyword:
            params['keywordExactMatch'] = ''
        logger.info("Built search parameters: %s", params)
        return params

    def _parse_response(self, response):
        if response.status_code == 200:
            vulnerabilities = response.json().get('vulnerabilities', [])
            parsed_vulnerabilities = []
            for vuln in vulnerabilities:
                cve = vuln.get('cve', {})
                metrics = cve.get('metrics', {}).get('cvssMetricV2', [{}])[0]
                parsed_vulnerabilities.append({
                    'cve': {
                        'id': cve.get('id', 'Unknown ID'),
                        'descriptions': cve.get('descriptions', [{'value': 'No description available'}]),
                        'published': cve.get('published', 'Unknown'),
                        'lastModified': cve.get('lastModified', 'Unknown'),
                        'metrics': {
                            'cvssMetricV2': [{
                                'baseSeverity': metrics.get('baseSeverity', 'Unknown'),
                                'impactScore': metrics.get('impactScore', 'Unknown'),
                                'exploitabilityScore': metrics.get('exploitabilityScore', 'Unknown')
                            }]
                        },
                        'references': cve.get('references', [{'url': 'No URL'}])
                    }
                })
            parsed_vulnerabilities.sort(
                key=lambda x: x['cve'].get('published', ''), reverse=True)
            logger.info("Parsed %d vulnerabilities", len(parsed_vulnerabilities))
            return parsed_vulnerabilities
        logger.error("Failed to fetch vulnerabilities. Status code: %d", response.status_code)
        return []