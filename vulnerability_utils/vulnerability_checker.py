from datetime import datetime

import requests

import config
from keyword_cleaner import KeywordCleaner
from log_and_file_managers.logger_manager import LoggerManager

logger_manager = LoggerManager(config.LOG_FILE)
logger = logger_manager.get_logger()


class VulnerabilityChecker:
    BASE_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    HEADERS = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36'
    }

    def __init__(self):
        self.keyword_cleaner = KeywordCleaner()

    def extract_keyword(self, vendor_name):
        cleaned_name = self.keyword_cleaner.clean_vendor_name(vendor_name)
        keywords = self.keyword_cleaner.extract_keywords(cleaned_name)
        best_keyword = self.keyword_cleaner.get_best_keyword(
            keywords, cleaned_name)
        logger.info(
            "Extracted keyword for vendor '%s': %s",
            vendor_name,
            best_keyword)
        return best_keyword

    def search_vulnerabilities(self, OS=None, vendor=None, device_name=None):
        keywords = set()
        logger.info(
            "Searching vulnerabilities for OS: %s, vendor: %s, device_name: %s",
            OS,
            vendor,
            device_name)

        cleaned_vendor = self.extract_keyword(
            vendor) if vendor and vendor.lower() != "unknown" else vendor
        keyword_combinations = []

        if cleaned_vendor and OS and device_name:
            keyword_combinations = [
                f"{cleaned_vendor} {OS} {device_name}",
                f"{cleaned_vendor} {device_name}",
                OS,
                device_name
            ]
        elif cleaned_vendor and OS:
            keyword_combinations = [
                f"{cleaned_vendor} {OS}",
                cleaned_vendor,
                OS
            ]
        elif cleaned_vendor and device_name:
            keyword_combinations = [
                f"{cleaned_vendor} {device_name}",
                cleaned_vendor,
                device_name
            ]
        elif OS and device_name:
            keyword_combinations = [
                f"{OS} {device_name}",
                OS,
                device_name
            ]
        elif cleaned_vendor:
            keyword_combinations = [cleaned_vendor]
        elif OS:
            keyword_combinations = [OS]
        elif device_name:
            keyword_combinations = [device_name]

        vulnerabilities = []
        for keyword in keyword_combinations:
            if 'unknown' not in keyword.lower():
                vulnerabilities.extend(self._search_by_keyword(keyword))

        # Remove duplicates and prioritize results
        unique_vulnerabilities = {v['cve']['id']                                  : v for v in vulnerabilities}.values()
        sorted_vulnerabilities = sorted(
            unique_vulnerabilities,
            key=lambda v: (
                v['cve']['published'], v['cve']['metrics']['cvssMetricV2'][0]['baseSeverity']),
            reverse=True)

        return list(sorted_vulnerabilities)

    def _search_by_keyword(self, keyword):
        if keyword != '':
            params = self._build_params(keyword)
            logger.info("Searching vulnerabilities with keyword: %s", keyword)
            response = requests.get(
                self.BASE_URL,
                params=params,
                headers=self.HEADERS)
            return self._parse_response(response)
        return []

    def _build_params(self, keyword):
        params = {
            'keywordSearch': keyword,
            'keywordExactMatch': ''
        }
        logger.info("Built search parameters: %s", params)
        return params

    def _parse_response(self, response):
        if response.status_code == 200:
            vulnerabilities = response.json().get('vulnerabilities', [])
            parsed_vulnerabilities = []
            for vuln in vulnerabilities:
                cve = vuln.get('cve', {})
                metrics = cve.get('metrics', {}).get('cvssMetricV2', [{}])[0]
                severity = metrics.get('baseSeverity', 'Unknown')
                description = cve.get('descriptions', [{'value': 'No description available'}])[
                    0].get('value', 'No description available')
                published_date = cve.get('published', 'Unknown')
                last_modified_date = cve.get('lastModified', 'Unknown')

                # Check for unresolved status (e.g., last modified date is recent)
                try:
                    last_modified_datetime = datetime.strptime(
                        last_modified_date, '%Y-%m-%dT%H:%M:%S.%f')
                    # Example: unresolved if modified within the last year
                    if (datetime.now() - last_modified_datetime).days > 365*2:
                        continue
                except ValueError:
                    continue

                parsed_vulnerabilities.append({
                    'cve': {
                        'id': cve.get('id', 'Unknown ID'),
                        'descriptions': description,
                        'published': published_date,
                        'lastModified': last_modified_date,
                        'metrics': {
                            'cvssMetricV2': [{
                                'baseSeverity': severity,
                                'impactScore': metrics.get('impactScore', 'Unknown'),
                                'exploitabilityScore': metrics.get('exploitabilityScore', 'Unknown')
                            }]
                        },
                        'references': [ref.get('url', 'No URL') for ref in cve.get('references', [])]
                    }
                })
            return parsed_vulnerabilities
        return []
